"""
Obsidian Writer — Direct file system access to Obsidian vault.

No Obsidian API — writes markdown files directly to the vault folder.
All notes use Obsidian-compatible syntax (YAML frontmatter, [[wikilinks]]).
"""

import logging
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

# Default vault path (iCloud Obsidian on Mac)
_DEFAULT_VAULT = os.path.expanduser(
    "~/Library/Mobile Documents/iCloud~md~obsidian/Documents"
)


class ObsidianWriter:
    """Write markdown notes directly to an Obsidian vault."""

    def __init__(self, vault_path: Optional[str] = None):
        self.vault_path = vault_path or os.getenv("OBSIDIAN_VAULT_PATH", _DEFAULT_VAULT)
        logger.info("ObsidianWriter: vault at %s", self.vault_path)

    # ------------------------------------------------------------------
    # Generic note
    # ------------------------------------------------------------------

    def save_note(
        self,
        title: str,
        content: str,
        folder: str = "Polaris/Research",
        tags: Optional[List[str]] = None,
        source: str = "polaris",
    ) -> str:
        """Save a markdown note with YAML frontmatter.

        Returns the full file path of the created note.
        """
        target_dir = Path(self.vault_path) / folder
        target_dir.mkdir(parents=True, exist_ok=True)

        safe_title = _sanitise_filename(title)
        file_path = target_dir / f"{safe_title}.md"

        now = datetime.now().strftime("%Y-%m-%d %H:%M")
        tag_str = "\n".join(f"  - {t}" for t in (tags or []))

        frontmatter = (
            "---\n"
            f"date: {now}\n"
            f"source: {source}\n"
        )
        if tag_str:
            frontmatter += f"tags:\n{tag_str}\n"
        frontmatter += "---\n\n"

        full_content = frontmatter + f"# {title}\n\n" + content

        file_path.write_text(full_content, encoding="utf-8")
        logger.info("Saved note: %s", file_path)
        return str(file_path)

    # ------------------------------------------------------------------
    # Paper note
    # ------------------------------------------------------------------

    def save_paper_note(self, paper_info: Dict, analysis: str) -> str:
        """Save a paper analysis as an Obsidian note.

        paper_info keys: title, authors, abstract, arxiv_id, year
        """
        title = paper_info.get("title", "Untitled Paper")
        authors = paper_info.get("authors", "Unknown")
        abstract = paper_info.get("abstract", "")
        arxiv_id = paper_info.get("arxiv_id", "")
        year = paper_info.get("year", datetime.now().year)

        content = (
            f"**Authors:** {authors}\n"
            f"**Year:** {year}\n"
        )
        if arxiv_id:
            content += f"**arXiv:** [{arxiv_id}](https://arxiv.org/abs/{arxiv_id})\n"
        content += (
            f"\n## Abstract\n{abstract}\n\n"
            f"## Analysis\n{analysis}\n\n"
            f"## 내 연구와의 연관\n\n"
            f"---\n"
            f"*Generated by [[Polaris]] on {datetime.now().strftime('%Y-%m-%d')}*\n"
        )

        return self.save_note(
            title=title,
            content=content,
            folder="Polaris/Papers",
            tags=["paper", "arxiv"],
            source="arxiv",
        )

    # ------------------------------------------------------------------
    # Daily log
    # ------------------------------------------------------------------

    def save_daily_log(self, date: Optional[str] = None, entries: Optional[List[str]] = None) -> str:
        """Save a daily activity log.

        entries: list of log lines (conversations, actions, insights).
        """
        if date is None:
            date = datetime.now().strftime("%Y-%m-%d")

        body = "\n".join(f"- {e}" for e in (entries or []))
        content = (
            f"## 대화 요약\n{body}\n\n"
            f"## 수행한 작업\n\n"
            f"## 인사이트\n\n"
            f"---\n"
            f"*Auto-generated by [[Polaris]]*\n"
        )

        return self.save_note(
            title=f"Daily Log {date}",
            content=content,
            folder="Polaris/DailyLogs",
            tags=["daily-log"],
            source="polaris",
        )

    # ------------------------------------------------------------------
    # master_prompt.md — 99_CURRENT_CONTEXT only
    # ------------------------------------------------------------------

    def read_master_prompt(self, path: Optional[str] = None) -> str:
        """Read the master_prompt.md file. Returns empty string if not found."""
        mp_path = self._resolve_master_prompt_path(path)
        if mp_path is None or not os.path.exists(mp_path):
            return ""
        return Path(mp_path).read_text(encoding="utf-8")

    def read_master_prompt_section(self, section_prefix: str, path: Optional[str] = None) -> str:
        """Extract a specific section (e.g. '00_CORE') from master_prompt.md.

        Returns the text from the section header until the next section of
        the same or higher level, or end of file.
        """
        content = self.read_master_prompt(path)
        if not content:
            return ""

        # Sections are typically ## 00_CORE_IDENTITY or similar
        # Use [^\n]* for the header line to avoid crossing newlines
        pattern = rf"(## [^\n]*{re.escape(section_prefix)}[^\n]*\n.*?)(?=\n## |\Z)"
        match = re.search(pattern, content, re.DOTALL)
        return match.group(1).strip() if match else ""

    def update_master_prompt(self, new_info: str, path: Optional[str] = None) -> bool:
        """Update ONLY the 99_CURRENT_CONTEXT section of master_prompt.md.

        All other sections are preserved exactly as-is.
        Returns True on success, False if file not found.
        """
        mp_path = self._resolve_master_prompt_path(path)
        if mp_path is None or not os.path.exists(mp_path):
            logger.warning("master_prompt.md not found at %s", mp_path)
            return False

        content = Path(mp_path).read_text(encoding="utf-8")

        # Find the 99_CURRENT_CONTEXT section
        pattern = r"(## 99_CURRENT_CONTEXT.*?)(?=\n## |\Z)"
        match = re.search(pattern, content, re.DOTALL)

        if match:
            # Replace existing section content, keeping the header
            section_header = "## 99_CURRENT_CONTEXT\n"
            updated_section = section_header + new_info.strip() + "\n"
            content = content[:match.start()] + updated_section + content[match.end():]
        else:
            # Section doesn't exist yet — append it
            content = content.rstrip() + "\n\n## 99_CURRENT_CONTEXT\n" + new_info.strip() + "\n"

        Path(mp_path).write_text(content, encoding="utf-8")
        logger.info("Updated 99_CURRENT_CONTEXT in %s", mp_path)
        return True

    def _resolve_master_prompt_path(self, path: Optional[str] = None) -> Optional[str]:
        """Resolve the master_prompt.md path from argument, env, or vault."""
        if path:
            return path
        # Try vault path
        vault_mp = Path(self.vault_path) / "master_prompt.md"
        if vault_mp.exists():
            return str(vault_mp)
        env_path = os.getenv("MASTER_PROMPT_PATH")
        if env_path:
            return env_path
        # Try project data directory
        project_mp = Path(__file__).parent.parent.parent / "data" / "master_prompt.md"
        if project_mp.exists():
            return str(project_mp)
        return None


def _sanitise_filename(name: str) -> str:
    """Remove characters that are unsafe in filenames."""
    return re.sub(r'[\\/:*?"<>|]', "_", name).strip()[:100]
